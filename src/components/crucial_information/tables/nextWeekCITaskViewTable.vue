<template>  <div>    <b-table striped hover :fields="tableFields" :items="crusialInformations">      <template #cell(dropdown)="props">        <i          :id="props.item"          class="dropdown bx bxs-chevron-down-circle task-detail-icon"          @click="toggleDetails(props)"        ></i>      </template>      <template #cell(planned_hour)="props">        <div style="width: 85px">{{ props.item.planned_hour }}</div>      </template>      <template #cell(process)="props">        <div style="width: 114px">          <b-progress            class="stage-progress"            :max="props.item.progress_max"            show-value          >            <b-progress-bar              :value="props.item.progress_complete"              variant="success"            ></b-progress-bar>            <b-progress-bar              :value="props.item.progress_onProcess"              variant="warning"            ></b-progress-bar>            <b-progress-bar              :value="props.item.progress_onQueue"              variant="danger"            ></b-progress-bar>          </b-progress>        </div>      </template>      <template #row-details="props">        <TableDetail :row-data="props.item" :options="props.item.stgGrp" />      </template>    </b-table>  </div></template><script>import TableDetail from '@/components/crucial_information/tables/nextWeekCITaskViewTableDetail';export default {  name: 'NextWeekCIApproveTable',  components: { TableDetail },  props: {    tableData: {      type: [Array, Object],      default() {        return [];      },    },    detailView: {      type: Boolean,      default() {        return false;      },    },  },  data() {    return {      perPage: 5,      tableFields: [        {          key: 'dropdown',          label: '',        },        {          key: 'task_code',          label: 'Task code',          sortable: true,        },        {          key: 'task_name',          label: 'Task name',          sortable: true,        },        {          key: 'planned_hour',          label: 'Plan hour',        },        {          key: 'process',          label: 'Process',          sortable: true,        },      ],      crusialInformations: [],      tasks: [],      taskList: [],      taskStgGrpList: [],      taskStgList: [],      isCheckedAll: false,      checkedList: [],    };  },  watch: {    detailView() {      this.showAllTaskDetail();    },    tasks(data) {      const algorithm = this.$store.getters.company.algorithm;      for (const i in this.taskList) {        for (const j in data) {          if (this.taskList[i].id === data[j].id) {            for (const o in algorithm) {              this.taskList[i].task_name = data[j].name;              this.taskList[i].task_code = data[j].code;              this.taskList[i].end_date = data[j].end_date;              this.taskList[i].id = data[j].id;              const stageGrpList = [];              let TotalHour = 0;              let TotalMin = 0;              let totalComplete = 0;              let totalOnQueue = 0;              let totalOnProcess = 0;              if (this.taskList[i].algorithm === algorithm[o].id) {                this.taskList[i].algorithm_name = algorithm[o].name;                for (const l in this.taskStgGrpList) {                  if (this.taskStgGrpList[l].taskId === this.taskList[i].id) {                    for (const p in algorithm[o].stage_groups) {                      if (                        algorithm[o].stage_groups[p].id ===                        this.taskStgGrpList[l].id                      ) {                        let stageTotalHour = 0;                        let stageTotalMin = 0;                        let complete = 0;                        let onQueue = 0;                        let onProcess = 0;                        this.taskStgGrpList[l].name =                          algorithm[o].stage_groups[p].name;                        this.taskStgGrpList[l].code =                          algorithm[o].stage_groups[p].code;                        this.taskStgGrpList[l].stages = [];                        for (const m in this.taskStgList) {                          if (                            this.taskStgGrpList[l].tskStgGrpId ===                            this.taskStgList[m].tskStgGrpId                          ) {                            for (const r in algorithm[o].stage_groups[p]                              .stages) {                              if (                                algorithm[o].stage_groups[p].stages[r].id ===                                this.taskStgList[m].id                              ) {                                this.taskStgList[m].code =                                  algorithm[o].stage_groups[p].stages[r].code;                                this.taskStgList[m].name =                                  algorithm[o].stage_groups[p].stages[r].name;                                this.taskStgGrpList[l].end_date =                                  this.taskStgList[m].end_date;                                if (this.taskStgList[m].state === 'complete') {                                  complete += 1;                                  totalComplete += 1;                                } else if (                                  this.taskStgList[m].state === 'on_queue'                                ) {                                  onQueue += 1;                                  totalOnQueue += 1;                                } else if (                                  this.taskStgList[m].state === 'on_process'                                ) {                                  onProcess += 1;                                  totalOnProcess += 1;                                }                                const planHour = this.taskStgList[m].plan_hour;                                const splicedList = planHour.split(':');                                const intPlanHour = parseInt(splicedList[0]);                                const intPlanMin = parseInt(splicedList[1]);                                stageTotalHour += intPlanHour;                                stageTotalMin += intPlanMin;                                if (stageTotalMin >= 60) {                                  const min = Math.floor(stageTotalMin / 60);                                  stageTotalMin = stageTotalMin - 60 * min;                                  stageTotalHour += min;                                }                                this.taskStgGrpList[l].stages.push(                                  this.taskStgList[m]                                );                              }                            }                          }                        }                        TotalHour += stageTotalHour;                        TotalMin += stageTotalMin;                        if (TotalMin >= 60) {                          const min = Math.floor(TotalMin / 60);                          TotalMin = TotalMin - 60 * min;                          TotalHour += min;                        }                        if (!stageTotalHour.toString().charAt(1)) {                          stageTotalHour = '0' + stageTotalHour;                        }                        if (!stageTotalMin.toString().charAt(1)) {                          stageTotalMin = '0' + stageTotalMin;                        }                        this.taskStgGrpList[l].planned_hour =                          stageTotalHour + ':' + stageTotalMin;                        this.taskStgGrpList[l].progress_complete = complete;                        this.taskStgGrpList[l].progress_onQueue = onQueue;                        this.taskStgGrpList[l].progress_onProcess = onProcess;                        this.taskStgGrpList[l].progress_max =                          onProcess + onQueue + complete;                      }                    }                    stageGrpList.push(this.taskStgGrpList[l]);                  }                }                if (!TotalHour.toString().charAt(1)) {                  TotalHour = '0' + TotalHour;                }                if (!TotalMin.toString().charAt(1)) {                  TotalMin = '0' + TotalMin;                }                this.taskList[i].stgGrp = stageGrpList;                this.taskList[i].planned_hour = TotalHour + ':' + TotalMin;              }              this.taskList[i].progress_complete = totalComplete;              this.taskList[i].progress_onQueue = totalOnQueue;              this.taskList[i].progress_onProcess = totalOnProcess;              this.taskList[i].progress_max =                totalOnProcess + totalOnQueue + totalComplete;            }          }        }      }      this.crusialInformations = this.taskList;    },  },  beforeMount() {    const data = [];    for (const i in this.tableData) {      if (this.tableData[i].json_data !== null) {        for (const j in this.tableData[i].json_data.planned_tasks) {          data.push(this.tableData[i].json_data.planned_tasks[j]);        }      }    }    const TaskStgGrpList = [];    const TaskStgList = [];    const TaskList = [];    for (const i in data) {      if (!TaskList.includes(data[i].task)) {        TaskList.push(data[i].task);        this.taskList.push({          id: data[i].task,          algorithm: data[i].algorithm,          employee: data[i].employee,        });      }      if (!TaskStgGrpList.includes(data[i].task_stage_group)) {        TaskStgGrpList.push(data[i].task_stage_group);        this.taskStgGrpList.push({          taskId: data[i].task,          tskStgGrpId: data[i].task_stage_group,          id: data[i].stage_group,        });      }      if (!TaskStgList.includes(data[i].task_stage)) {        TaskStgList.push(data[i].task_stage);        this.taskStgList.push({          taskId: data[i].task,          tskStgGrpId: data[i].task_stage_group,          tskStgId: data[i].task_stage,          id: data[i].stage,          plan_hour: data[i].plan_hour,          state: data[i].state,          start_date: data[i].start_date,          end_date: data[i].end_date,        });      } else {        const planHour = data[i].plan_hour;        const splicedList = planHour.split(':');        let dataPlanHour = parseInt(splicedList[0]);        let dataPlanMin = parseInt(splicedList[1]);        for (const j in this.taskStgList) {          if (this.taskStgList[j].tskStgId === data[i].task_stage) {            const planHour = this.taskStgList[j].plan_hour;            const splicedList = planHour.split(':');            const intPlanHour = parseInt(splicedList[0]);            const intPlanMin = parseInt(splicedList[1]);            dataPlanHour += intPlanHour;            dataPlanMin += intPlanMin;            if (dataPlanHour >= 60) {              const min = Math.floor(dataPlanMin / 60);              dataPlanMin = dataPlanMin - 60 * min;              dataPlanHour += min;            }            if (!dataPlanHour.toString().charAt(1)) {              dataPlanHour = '0' + dataPlanHour;            }            if (!dataPlanMin.toString().charAt(1)) {              dataPlanMin = '0' + dataPlanMin;            }            this.taskStgList[j].plan_hour = dataPlanHour + ':' + dataPlanMin;          }        }      }    }    this.getTaskInfoByIds({ ids: TaskList });  },  mounted() {},  methods: {    async getTaskInfoByIds(param) {      const response = await this.$store.dispatch('getTaskInfoByIds', param);      if (response.status === 200) {        this.tasks = response.data.return_data;      }    },    toggleDetails(rowData) {      this.$set(        this.crusialInformations[rowData.index],        '_showDetails',        !this.crusialInformations[rowData.index]._showDetails      );    },    showAllTaskDetail() {      for (const i in this.crusialInformations) {        this.toggleClass(this.crusialInformations[i].task_id);        this.$set(this.crusialInformations[i], '_showDetails', this.detailView);      }    },    async toggleClass(data) {      await document.getElementById(data).classList.toggle('active');    },    toggleAll() {      for (const i in this.crusialInformations) {        if (this.crusialInformations[i].state === 'sent') {          this.crusialInformations[i].is_checked = this.isCheckedAll;          if (this.isCheckedAll) {            this.checkedList.push(this.crusialInformations[i].id);          } else {            this.checkedList = [];          }        }      }    },    checked(data) {      if (data.is_checked && data.state === 'sent') {        this.checkedList.push(data.id);      } else {        const index = this.checkedList.indexOf(data.id);        if (index > -1) {          this.checkedList.splice(index, 1);        }      }    },  },};</script><style scoped>.state {  text-align: center;  border-radius: 50px;}.action {  background: #1f304a;  border-radius: 4px;  color: white;}</style>