<template>  <div>    <b-table striped hover :fields="tableFields" :items="tableDatas">      <template #cell(sequence)="props">        {{ props.index + 1 }}      </template>      <template #cell(dropdown)="props">        <i          :id="props.item"          class="dropdown bx bxs-chevron-down-circle task-detail-icon"          :class="{ active: props.detailsShowing === true }"          @click="toggleDetails(props)"        ></i>      </template>      <template #cell(planned_hour)="props">        <div style="width: 85px">{{ props.item.planned_hour }}</div>      </template>      <template #cell(process)="props">        <div style="width: 114px">          <b-progress            class="stage-progress"            :max="props.item.progress.max"            show-value          >            <b-progress-bar              :value="props.item.progress.complete"              variant="success"            ></b-progress-bar>            <b-progress-bar              :value="props.item.progress.onProcess"              variant="warning"            ></b-progress-bar>            <b-progress-bar              :value="props.item.progress.onQueue"              variant="danger"            ></b-progress-bar>          </b-progress>        </div>      </template>      <template #row-details="props">        <TableDetail :row-data="props.item" :options="props.item.stgGrp" />      </template>    </b-table>  </div></template><script>import TableDetail from '@/components/crucial_information/tables/dashboardTableDetail';export default {  name: 'DashboardPlanTable',  components: { TableDetail },  props: {    tableData: {      type: [Array, Object],      default() {        return [];      },    },  },  data() {    return {      totalRows: 1,      tableFields: [        {          key: 'sequence',          label: '',        },        {          key: 'task_code',          label: 'Task code',          sortable: true,        },        {          key: 'task_name',          label: 'Task name',          sortable: true,        },        {          key: 'planned_hour',          label: 'Plan hour',        },        {          key: 'process',          label: 'Process',          sortable: true,        },        {          key: 'dropdown',          label: '',        },      ],      tableDatas: [],      taskDatas: [],      taskList: [],      taskStgList: [],      taskStgGrpList: [],      taskNameList: [],    };  },  watch: {    tableData(data) {      this.tableDatas = [];      this.taskList = [];      this.taskDatas = [];      this.taskStgList = [];      this.taskStgGrpList = [];      const TaskStgGrpList = [];      const TaskStgList = [];      const TaskList = [];      for (const i in data) {        if (!TaskList.includes(data[i].task)) {          TaskList.push(data[i].task);          this.taskList.push({            id: data[i].task,            algorithm: data[i].algorithm,            employee: data[i].employee,          });        }        if (!TaskStgGrpList.includes(data[i].task_stage_group)) {          TaskStgGrpList.push(data[i].task_stage_group);          this.taskStgGrpList.push({            taskId: data[i].task,            tskStgGrpId: data[i].task_stage_group,            id: data[i].stage_group,          });        }        if (!TaskStgList.includes(data[i].task_stage)) {          TaskStgList.push(data[i].task_stage);          this.taskStgList.push({            taskId: data[i].task,            tskStgGrpId: data[i].task_stage_group,            tskStgId: data[i].task_stage,            id: data[i].stage,            plan_hour: data[i].plan_hour,            state: data[i].state,            start_date: data[i].start_date,            end_date: data[i].end_date,          });        } else {          const planHour = data[i].plan_hour;          const splicedList = planHour.split(':');          let dataPlanHour = parseInt(splicedList[0]);          let dataPlanMin = parseInt(splicedList[1]);          for (const j in this.taskStgList) {            if (this.taskStgList[j].tskStgId === data[i].task_stage) {              const planHour = this.taskStgList[j].plan_hour;              const splicedList = planHour.split(':');              const intPlanHour = parseInt(splicedList[0]);              const intPlanMin = parseInt(splicedList[1]);              dataPlanHour += intPlanHour;              dataPlanMin += intPlanMin;              if (dataPlanHour >= 60) {                const min = Math.floor(dataPlanMin / 60);                dataPlanMin = dataPlanMin - 60 * min;                dataPlanHour += min;              }              if (!dataPlanHour.toString().charAt(1)) {                dataPlanHour = '0' + dataPlanHour;              }              if (!dataPlanMin.toString().charAt(1)) {                dataPlanMin = '0' + dataPlanMin;              }              this.taskStgList[j].plan_hour = dataPlanHour + ':' + dataPlanMin;            }          }        }      }      this.getTaskInfoByIds({ ids: TaskList });    },    taskNameList(data) {      const algorithm = this.$store.getters.company.algorithm;      for (const i in this.taskList) {        let totalComplete = 0;        let totalOnQueue = 0;        let totalOnProcess = 0;        for (const j in data) {          if (this.taskList[i].id === data[j].id) {            for (const o in algorithm) {              this.taskList[i].task_name = data[j].name;              this.taskList[i].task_code = data[j].code;              this.taskList[i].end_date = data[j].end_date;              this.taskList[i].id = data[j].id;              const stageGrpList = [];              let TotalHour = 0;              let TotalMin = 0;              if (this.taskList[i].algorithm === algorithm[o].id) {                this.taskList[i].algorithm_name = algorithm[o].name;                for (const l in this.taskStgGrpList) {                  if (this.taskStgGrpList[l].taskId === this.taskList[i].id) {                    for (const p in algorithm[o].stage_groups) {                      if (                        algorithm[o].stage_groups[p].id ===                        this.taskStgGrpList[l].id                      ) {                        let stageTotalHour = 0;                        let stageTotalMin = 0;                        let complete = 0;                        let onQueue = 0;                        let onProcess = 0;                        this.taskStgGrpList[l].name =                          algorithm[o].stage_groups[p].name;                        this.taskStgGrpList[l].code =                          algorithm[o].stage_groups[p].code;                        this.taskStgGrpList[l].stages = [];                        for (const m in this.taskStgList) {                          if (                            this.taskStgGrpList[l].tskStgGrpId ===                            this.taskStgList[m].tskStgGrpId                          ) {                            for (const r in algorithm[o].stage_groups[p]                              .stages) {                              if (                                algorithm[o].stage_groups[p].stages[r].id ===                                this.taskStgList[m].id                              ) {                                this.taskStgList[m].code =                                  algorithm[o].stage_groups[p].stages[r].code;                                this.taskStgList[m].name =                                  algorithm[o].stage_groups[p].stages[r].name;                                this.taskStgGrpList[l].end_date =                                  this.taskStgList[m].end_date;                                if (this.taskStgList[m].state === 'complete') {                                  complete += 1;                                  totalComplete += 1;                                } else if (                                  this.taskStgList[m].state === 'on_queue'                                ) {                                  onQueue += 1;                                  totalOnQueue += 1;                                } else if (                                  this.taskStgList[m].state === 'on_process'                                ) {                                  onProcess += 1;                                  totalOnProcess += 1;                                }                                const planHour = this.taskStgList[m].plan_hour;                                const splicedList = planHour.split(':');                                const intPlanHour = parseInt(splicedList[0]);                                const intPlanMin = parseInt(splicedList[1]);                                stageTotalHour += intPlanHour;                                stageTotalMin += intPlanMin;                                if (stageTotalMin >= 60) {                                  const min = Math.floor(stageTotalMin / 60);                                  stageTotalMin = stageTotalMin - 60 * min;                                  stageTotalHour += min;                                }                                this.taskStgGrpList[l].stages.push(                                  this.taskStgList[m]                                );                              }                            }                          }                        }                        TotalHour += stageTotalHour;                        TotalMin += stageTotalMin;                        if (TotalMin >= 60) {                          const min = Math.floor(TotalMin / 60);                          TotalMin = TotalMin - 60 * min;                          TotalHour += min;                        }                        if (!stageTotalHour.toString().charAt(1)) {                          stageTotalHour = '0' + stageTotalHour;                        }                        if (!stageTotalMin.toString().charAt(1)) {                          stageTotalMin = '0' + stageTotalMin;                        }                        this.taskStgGrpList[l].planned_hour =                          stageTotalHour + ':' + stageTotalMin;                        const progress = {};                        progress.complete = complete;                        progress.onQueue = onQueue;                        progress.onProcess = onProcess;                        progress.max = onProcess + onQueue + complete;                        this.taskStgGrpList[l].progress = progress;                      }                    }                    stageGrpList.push(this.taskStgGrpList[l]);                  }                }                if (!TotalHour.toString().charAt(1)) {                  TotalHour = '0' + TotalHour;                }                if (!TotalMin.toString().charAt(1)) {                  TotalMin = '0' + TotalMin;                }                this.taskList[i].stgGrp = stageGrpList;                this.taskList[i].planned_hour = TotalHour + ':' + TotalMin;              }              const progress = {};              progress.complete = totalComplete;              progress.onQueue = totalOnQueue;              progress.onProcess = totalOnProcess;              progress.max = totalOnProcess + totalOnQueue + totalComplete;              this.taskList[i].progress = progress;            }          }        }      }      this.tableDatas = this.taskList;      console.log('taskList', this.taskList);    },  },  mounted() {},  methods: {    linkGen(pageNum) {      return pageNum === 1 ? '?' : `?page=${pageNum}`;    },    toggleDetails(rowData) {      // this.$refs.createCItable.toggleDetailRow(rowData.task_id);      this.$set(        this.taskList[rowData.index],        '_showDetails',        !this.taskList[rowData.index]._showDetails      );    },    async getTaskInfoByIds(param) {      const response = await this.$store.dispatch('getTaskInfoByIds', param);      if (response.status === 200) {        this.taskNameList = response.data.return_data;      }    },  },};</script><style scoped></style>