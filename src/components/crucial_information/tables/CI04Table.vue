<template>  <div>    <b-table      id="CI04table"      ref="CI04table"      striped      :fields="tableField"      :items="Tasks"    >      <template #cell(sequence)="props">        {{ props.index + 1 }}      </template>      <template #cell(dropdown)="props">        <i          :id="props.item"          class="dropdown bx bxs-chevron-down-circle task-detail-icon"          :class="{ active: props.detailsShowing === true }"          @click="showTaskDetail(props)"        ></i>      </template>      <template #cell(task_name)="props">        <router-link          :to="{            name: 'task-detail',            query: {              id: props.item.task_id,            },          }"          class="task-link"        >          {{ props.item.task_name }}        </router-link>      </template>      <template #cell(plan_hour)="props">        <p>{{ props.item.plan_hour }}</p>      </template>      <template #cell(process)="props">        <b-progress          class="stage-progress"          :max="props.item.maxPorgress"          show-value          style="width: 150px"        >          <b-progress-bar            :value="props.item.progress.complete"            variant="success"          ></b-progress-bar>          <b-progress-bar            :value="props.item.progress.onProcess"            variant="warning"          ></b-progress-bar>          <b-progress-bar            :value="props.item.progress.onQueue"            variant="danger"          ></b-progress-bar>        </b-progress>      </template>      <template #row-details="props">        <Ci04TableDetail          :row-data="props.item"          :planned-task="props.item.task_stage_groups"          :algorithm="props.item.algorithm"          :task-id="props.item.task_id"        />      </template>    </b-table>  </div></template><script>import Ci04TableDetail from '@/components/crucial_information/tables/CI04TableDetail';export default {  name: 'CI04Table',  components: { Ci04TableDetail },  props: {    tasks: {      type: [Array, Object],      default() {        return [];      },    },    weekDate: {      type: String,      default() {        return '';      },    },  },  data() {    return {      tableField: [        {          key: 'sequence',          label: '',        },        {          key: 'task_code',          label: 'Task code',          sortable: true,        },        {          key: 'task_name',          label: 'Task name',          sortable: true,        },        {          key: 'plan_hour',          label: 'Planned time',          sortable: true,        },        {          key: 'process',          label: 'Process',          sortable: true,        },        {          key: 'dropdown',          label: '',        },      ],      Tasks: [{ task_stage_groups: [] }],      TaskDetails: [],    };  },  watch: {    tasks(data) {      this.Tasks = data;      for (const i in this.Tasks) {        let maxPorgress = 0;        let complete = 0;        let onQueue = 0;        let onProcess = 0;        let planHour = 0;        let planMin = 0;        this.Tasks[i].task_stage_groups = [];        const taskStageGrpList = [];        for (const j in this.Tasks[i].task_stages) {          const splicedList = this.Tasks[i].task_stages[j].plan_hour.split(':');          let intPlanHour = parseInt(splicedList[0]);          let intPlanMin = parseInt(splicedList[1]);          planHour += intPlanHour;          planMin += intPlanMin;          if (planMin >= 60) {            const min = Math.floor(planMin / 60);            planMin = planMin - 60 * min;            planHour += min;          }          if (            !taskStageGrpList.includes(              this.Tasks[i].task_stages[j].task_stage_group            )          ) {            taskStageGrpList.push(              this.Tasks[i].task_stages[j].task_stage_group            );            const jsonData = {              task_stage_group_id:                this.Tasks[i].task_stages[j].task_stage_group,              stage_group_id: this.Tasks[i].task_stages[j].stage_group,              task_stages: [],              plan_hour: '00:00',            };            if (              this.Tasks[i].task_stages[j].entry &&              this.Tasks[i].task_stages[j].form            ) {              jsonData.form = this.Tasks[i].task_stages[j].form;              jsonData.entry = this.Tasks[i].task_stages[j].entry;            }            this.Tasks[i].task_stage_groups.push(jsonData);          }          maxPorgress += 1;          if (this.Tasks[i].task_stages[j].state === 'complete') {            complete += 1;          } else if (this.Tasks[i].task_stages[j].state === 'on_queue') {            onQueue += 1;          } else if (this.Tasks[i].task_stages[j].state === 'on_process') {            onProcess += 1;          }        }        if (!planHour.toString().charAt(1)) {          planHour = '0' + planHour;        }        if (!planMin.toString().charAt(1)) {          planMin = '0' + planMin;        }        this.Tasks[i].plan_hour = planHour + ':' + planMin;        const progress = {};        progress.complete = complete;        progress.onQueue = onQueue;        progress.onProcess = onProcess;        this.Tasks[i].progress = progress;        this.Tasks[i].maxPorgress = maxPorgress;      }      const algorithms = this.$store.getters.company.algorithm;      for (const i in this.Tasks) {        for (const j in algorithms) {          if (this.Tasks[i].algorithm === algorithms[j].id) {            for (const l in this.Tasks[i].task_stage_groups) {              let complete = 0;              let onQueue = 0;              let onProcess = 0;              let StgGrpHour = 0;              let StgGrpMin = 0;              const taskStages = [];              for (const m in algorithms[j].stage_groups) {                if (                  algorithms[j].stage_groups[m].id ===                  this.Tasks[i].task_stage_groups[l].stage_group_id                ) {                  this.Tasks[i].task_stage_groups[l].stage_group_name =                    algorithms[j].stage_groups[m].name;                  this.Tasks[i].task_stage_groups[l].stage_group_code =                    algorithms[j].stage_groups[m].code;                }                for (const n in this.Tasks[i].task_stages) {                  if (                    this.Tasks[i].task_stages[n].task_stage_group ===                    this.Tasks[i].task_stage_groups[l].task_stage_group_id                  ) {                    for (const o in algorithms[j].stage_groups[m].stages) {                      if (                        this.Tasks[i].task_stages[n].stage ===                        algorithms[j].stage_groups[m].stages[o].id                      ) {                        this.Tasks[i].task_stages[n].stage_code =                          algorithms[j].stage_groups[m].stages[o].code;                        this.Tasks[i].task_stages[n].stage_name =                          algorithms[j].stage_groups[m].stages[o].name;                        taskStages.push(this.Tasks[i].task_stages[n]);                        const splicedList =                          this.Tasks[i].task_stages[n].plan_hour.split(':');                        let intPlanHour = parseInt(splicedList[0]);                        let intPlanMin = parseInt(splicedList[1]);                        StgGrpHour += intPlanHour;                        StgGrpMin += intPlanMin;                        if (StgGrpMin >= 60) {                          const min = Math.floor(StgGrpMin / 60);                          StgGrpMin = StgGrpMin - 60 * min;                          StgGrpHour += min;                        }                        if (this.Tasks[i].task_stages[n].state === 'complete') {                          complete += 1;                        } else if (                          this.Tasks[i].task_stages[n].state === 'on_queue'                        ) {                          onQueue += 1;                        } else if (                          this.Tasks[i].task_stages[n].state === 'on_process'                        ) {                          onProcess += 1;                        }                      }                    }                  }                }              }              if (!StgGrpHour.toString().charAt(1)) {                StgGrpHour = '0' + StgGrpHour;              }              if (!StgGrpMin.toString().charAt(1)) {                StgGrpMin = '0' + StgGrpMin;              }              this.Tasks[i].task_stage_groups[l].plan_hour =                StgGrpHour + ':' + StgGrpMin;              this.Tasks[i].task_stage_groups[l].task_stages = taskStages;              const progress = {};              progress.complete = complete;              progress.onQueue = onQueue;              progress.onProcess = onProcess;              this.Tasks[i].task_stage_groups[l].progress = progress;              this.Tasks[i].task_stage_groups[l].maxPorgress =                complete + onQueue + onProcess;            }          }        }      }    },  },  methods: {    showTaskDetail(rowData) {      this.$set(        this.Tasks[rowData.index],        '_showDetails',        !this.Tasks[rowData.index]._showDetails      );    },    stageCount(tskId, type = null) {      let count = 0;      for (const stage of this.tasks.task_stage_ids) {        if (type === null) {          if (stage.task === tskId) {            count = count + 1;          }        } else if (stage.task === tskId && stage.state === 'complete') {          count = count + 1;        }      }      return count;    },    getState(tskId) {      const states = [];      for (const stage of this.tasks.task_stage_ids) {        if (stage.task === tskId) {          states.push(stage.state);        }      }      if (states.includes('on_queue')) return 'on_queue';      if (states.includes('on_process')) return 'on_process';      if (states.includes('complete')) return 'complete';      return 'on_queue';    },  },};</script>