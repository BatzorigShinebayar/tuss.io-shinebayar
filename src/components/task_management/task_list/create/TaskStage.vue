<template>  <div>    <TaskStageSlider      v-for="stage in algorithmStages"      :key="stage.id"      :executor="executor"      :team="team"      :slider-value="value"      :default-value="defaultValue"      :can-repeat="canRepeat"      :stage="stage"      :tuss-repeat="use_repeated"      :alg-id="algorithm"      @slider="setData"    />    <p v-if="!$v.sliderData.required && formSubmit" class="text-danger mb-4">      Task stage must set    </p>  </div></template><script>import { required, minLength } from 'vuelidate/lib/validators';import TaskStageSlider from '@/components/task_management/task_list/create/TaskStageSlider';export default {  name: 'TaskStage',  components: {    TaskStageSlider,  },  props: {    formSubmit: Boolean,    executor: {      type: Number,      default() {        return null;      },    },    team: {      type: Array,      default() {        return null;      },    },    algorithm: {      type: Number,      default() {        return null;      },    },    frequency: {      type: Object,      default() {        return {};      },    },  },  data() {    return {      algorithmStages: null,      value: null,      sliderData: [],      canRepeat: false,      defaultValue: null,      use_repeated: false,      is_system_alg: false,    };  },  watch: {    executor() {      this.setAlgorithm();    },    team() {      this.setAlgorithm();    },    algorithm(id) {      this.checksystemDefault();      if (!this.is_system_alg) {        this.getOrganizationAlgorithm(          '?organization=' +            this.$store.getters.activeCompany +            '&algorithm=' +            id        );      } else {        this.sliderData = null;        this.value = null;        this.setAlgorithm();      }    },    frequency() {      this.sliderData = null;      this.setAlgorithm();    },  },  validations: {    sliderData: { required, minLength: minLength(1) },  },  methods: {    checksystemDefault() {      const allAlgorithm = this.$store.getters.company.algorithm;      for (const algorithm of allAlgorithm) {        if (algorithm.id === this.algorithm) {          this.is_system_alg = algorithm.is_system_default;        }      }    },    async getOrganizationAlgorithm(params) {      const response = await this.$store.dispatch(        'getOrganizationAlgorithm',        params      );      if (response.status === 200 && response.data.total > 0) {        this.use_repeated = response.data.results[0].use_repeated;        this.algorithmStages = [];        this.sliderData = null;        this.value = null;        this.setAlgorithm();      }    },    setAlgorithm() {      const allAlgorithm = this.$store.getters.company.algorithm;      const stageGroups = [];      for (const algorithm of allAlgorithm) {        if (algorithm.id === this.algorithm) {          const stages = algorithm.stage_groups;          for (const stage of stages) {            if (stage.is_active === '1') {              stageGroups.push(stage);            }          }          break;        }      }      if (!this.frequency) {        return;      }      this.canRepeat = this.frequency.frequency !== 'one_time';      const diffTime = Math.abs(        new Date(this.frequency.endDate) - new Date(this.frequency.startDate)      );      const repeat = Math.ceil(diffTime / (1000 * 60 * 60 * 24));      this.defaultValue = this.setOneTime(repeat);      if (this.frequency.frequency === 'one_time') {        this.value = this.setOneTime();      } else if (this.frequency.frequency === 'weekly') {        this.value = this.setWeekly();      } else if (this.frequency.frequency === 'monthly') {        this.value = this.setMonthly();      } else if (this.frequency.frequency === 'quarterly') {        this.value = this.setQuarterly();      } else if (this.frequency.frequency === 'half_year') {        this.value = this.setBiAnnual();      } else if (this.frequency.frequency === 'yearly') {        this.value = this.setAnnual();      }      this.algorithmStages = stageGroups;    },    setOneTime(repeat = false) {      const startDate = new Date(this.frequency.startDate);      let day = '';      if (repeat) {        day = repeat;      } else {        day = this.frequency.repeat;      }      const sliderValue = [];      let i;      for (i = 0; i <= day; i++) {        const epochDay = i * 1000 * 60 * 60 * 24;        const epochDate = startDate.getTime() + epochDay;        const day = new Date(epochDate);        const dayString = day.toISOString().slice(0, 10);        sliderValue.push({          value: dayString,          label: dayString,        });      }      return sliderValue;    },    setWeekly() {      return [        { value: 1, label: 'Monday' },        { value: 2, label: 'Tueday' },        { value: 3, label: 'Wednesday' },        { value: 4, label: 'Thursday' },        { value: 5, label: 'Friday' },        { value: 6, label: 'Saturday' },        { value: 7, label: 'Sunday' },      ];    },    setMonthly() {      const sliderValue = [];      let i;      for (i = 1; i <= 30; i++) {        sliderValue.push({          value: i,          label: i,        });      }      return sliderValue;    },    setQuarterly() {      const sliderValue = [];      let i;      for (i = 1; i <= 90; i++) {        sliderValue.push({          value: i,          label: i,        });      }      return sliderValue;    },    setBiAnnual() {      const sliderValue = [];      let i;      for (i = 1; i <= 180; i++) {        sliderValue.push({          value: i,          label: i,        });      }      return sliderValue;    },    setAnnual() {      const sliderValue = [];      let i;      for (i = 1; i <= 365; i++) {        sliderValue.push({          value: i,          label: i,        });      }      return sliderValue;    },    // emit from slider    setData(sliderData) {      if (sliderData.start > sliderData.end) {        const temporary = sliderData.start;        sliderData.start = sliderData.end;        sliderData.end = temporary;      }      // first time      if (!this.sliderData) {        this.sliderData = [sliderData];        this.$emit('getTaskStage', this.sliderData);      }      // second time add or update      let i;      for (i = 0; i < this.sliderData.length; i++) {        if (this.sliderData[i].id === sliderData.id) {          this.sliderData[i] = sliderData;          return;        }      }      this.sliderData.push(sliderData);      this.$emit('getTaskStage', this.sliderData);    },  },};</script>