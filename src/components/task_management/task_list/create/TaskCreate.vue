<template>  <b-sidebar    id="task-create"    title="Create new task"    right    shadow    backdrop    lazy    class="sidebar-lg"    @hidden="clearSidebar"  >    <div class="p-4">      <TaskName :formSubmit="formSubmit" @getName="getName" />      <TaskDepartment :formSubmit="formSubmit" @getDepartment="getDepartment" />      <TaskType :formSubmit="formSubmit" @getType="getTaskType" />      <TaskFunction :formSubmit="formSubmit" @getFunction="getFunction" />      <TaskFrequency :formSubmit="formSubmit" @getFrequency="getFrequency" />      <TaskAlgorithm :formSubmit="formSubmit" @getAlgorithm="getAlgorithm" />      <TaskExecutor :formSubmit="formSubmit" @getExecutor="getExecutor" />      <TaskTeam :formSubmit="formSubmit" @getTaskTeam="getTaskTeam" />      <TaskStage        :formSubmit="formSubmit"        :executor="taskExecutor"        :team="taskTeam"        :algorithm="selectedAlgorithm"        :frequency="taskFrequency"        @getTaskStage="getTaskStage"      />    </div>    <template #footer>      <div class="bg-light d-flex justify-content-between py-3 px-4">        <b-button-group size="lg" class="w-100">          <b-button variant="deep-blue" @click="createTask">            Create task          </b-button>          <b-button variant="outline-deep-blue" @click="closeTask">            Cancel          </b-button>        </b-button-group>      </div>    </template>  </b-sidebar></template><script>import axios from 'axios';import { required, maxLength } from 'vuelidate/lib/validators';import TaskName from '@/components/task_management/task_list/create/TaskName';import TaskDepartment from '@/components/task_management/task_list/create/TaskDepartment';import TaskType from '@/components/task_management/task_list/create/TaskType';import TaskFunction from '@/components/task_management/task_list/create/TaskFunction';import TaskFrequency from '@/components/task_management/task_list/create/TaskFrequency';import TaskAlgorithm from '@/components/task_management/task_list/create/TaskAlgorithm';import TaskExecutor from '@/components/task_management/task_list/create/TaskExecutor';import TaskTeam from '@/components/task_management/task_list/create/TaskTeam';import TaskStage from '@/components/task_management/task_list/create/TaskStage';export default {  name: 'TaskCreate',  components: {    TaskName,    TaskDepartment,    TaskType,    TaskFunction,    TaskFrequency,    TaskAlgorithm,    TaskExecutor,    TaskTeam,    TaskStage,  },  data() {    return {      taskName: null,      departmentSelected: null,      departmentManager: null,      taskTypesSelected: null,      functionsSelected: null,      taskFrequency: null,      selectedAlgorithm: null,      taskExecutor: null,      taskTeam: null,      taskStageGroup: null,      formSubmit: false,      taskStatusMessage: null,      toastCounter: 0,      newTaskId: 0,      normalizer(node) {        return {          id: node.id,          label: node.name,          children: node.sub_function,        };      },    };  },  validations: {    taskName: { required, maxLength: maxLength(255) },    departmentSelected: { required },    taskTypesSelected: { required },    functionsSelected: { required },    taskFrequency: { required },    selectedAlgorithm: { required },    taskExecutor: { required },    taskStageGroup: { required },  },  methods: {    getName(value) {      this.taskName = value;    },    getDepartment(value) {      this.departmentManager = value.departmentManager;      this.departmentSelected = value.departmentId;    },    getTaskType(value) {      this.taskTypesSelected = value;    },    getFunction(value) {      this.functionsSelected = value;    },    getFrequency(value) {      this.taskFrequency = value;    },    getAlgorithm(value) {      this.selectedAlgorithm = value;    },    getExecutor(executor) {      this.taskExecutor = executor;    },    getTaskTeam(team) {      this.taskTeam = team;    },    getTaskStage(stage) {      this.taskStageGroup = stage;    },    taskStatusSuccess() {      const h = this.$createElement;      const id = `task-toast-${this.toastCounter++}`;      const $text = h('p', { class: 'mb-3' }, this.taskStatusMessage);      const $closeButton = h(        'b-button',        {          on: { click: () => this.$bvToast.hide(id) },          props: { variant: 'outline-deep-blue' },          class: 'mr-2',        },        'Close'      );      const $viewButton = h(        'b-button',        {          on: {            click: () => {              this.$bvToast.hide(id);              this.$router                .push({                  name: 'task-detail',                  query: { id: this.newTaskId },                })                .catch(() => {                  window.location.reload();                });            },          },          props: {            variant: 'deep-blue',          },        },        'View task'      );      this.$bvToast.toast([$text, $closeButton, $viewButton], {        id: id,        title: 'Task created',        appendToast: true,        variant: 'primary',        solid: true,        toaster: 'b-toaster-bottom-right',        noAutoHide: true,      });    },    taskStatusFail() {      this.$bvToast.toast('Something went wrong, Please try again.', {        title: 'Task not created',        appendToast: true,        variant: 'danger',        solid: true,        toaster: 'b-toaster-bottom-right',        'no-auto-hide': true,      });    },    closeTask() {      this.$root.$emit('bv::toggle::collapse', 'task-create');    },    createTask() {      // form validation      this.formSubmit = true;      this.$v.$touch();      const organization = this.$store.getters.activeCompany;      const currentUser = this.$store.getters.user.id;      const currentPartner = this.$store.getters.user.partner__id;      if (!this.$v.$invalid) {        const members = [];        // adding task executor        members.push({          team_member: this.taskExecutor,          start_date: this.taskFrequency.startDate,          end_date: this.taskFrequency.endDate,        });        // adding department manager        members.push({          team_member: this.departmentManager,          start_date: this.taskFrequency.startDate,          end_date: this.taskFrequency.endDate,        });        if (this.taskTeam) {          for (const member of this.taskTeam) {            members.push({              team_member: member,              start_date: this.taskFrequency.startDate,              end_date: this.taskFrequency.endDate,            });          }        }        // removing duplicate        const taskTeam = Array.from(          members.reduce((m, t) => m.set(t.team_member, t), new Map()).values()        );        const taskData = {          name: this.taskName,          department_id: this.departmentSelected,          task_type: this.taskTypesSelected,          sub_function_id: this.functionsSelected,          planned_start_date: this.taskFrequency.startDate,          start_date: this.taskFrequency.startDate,          planned_end_date: this.taskFrequency.endDate,          end_date: this.taskFrequency.endDate,          executing_employee: this.taskExecutor,          organization,          algorithm: this.selectedAlgorithm,          initiator: this.taskExecutor,          created_user: currentUser,          updated_user: currentUser,          task_team: taskTeam,          task_stage_groups: this.generateStageGroup(),          created_employee: currentPartner,          updated_employee: currentPartner,          is_repeated: this.is_repeat(),          frequency: this.taskFrequency.frequency,        };        this.$root.$emit('bv::toggle::collapse', 'task-create');        axios          .post('pages/plan/create_task/', taskData)          .then((response) => {            this.taskStatusMessage = taskData.name;            this.newTaskId = response.data.task_id;            this.taskStatusSuccess();          })          .catch(() => {            this.taskStatusFail();          });      }    },    generateStageGroup() {      if (this.taskFrequency.frequency === 'one_time') {        return this.GenerateOneTime();      } else if (this.taskFrequency.frequency === 'weekly') {        return this.GenerateWeekly();      } else if (this.taskFrequency.frequency === 'monthly') {        return this.GenerateMonthly();      } else if (this.taskFrequency.frequency === 'quarterly') {        return this.GenerateQuarterly();      } else if (this.taskFrequency.frequency === 'half_year') {        return this.GenerateBiAnnual();      } else if (this.taskFrequency.frequency === 'yearly') {        return this.GenerateAnnually();      }    },    is_repeat() {      return this.taskFrequency.frequency !== 'one_time';    },    // one time-----------------------------------------------------------------    GenerateOneTime() {      const fullStage = [];      let algorithm;      for (const storeAlgorithm of this.$store.getters.company.algorithm) {        if (this.selectedAlgorithm === storeAlgorithm.id) {          algorithm = storeAlgorithm;          break;        }      }      for (const stageGroup of algorithm.stage_groups) {        if (stageGroup.is_active === '1') {          for (const sData of this.taskStageGroup) {            if (sData.id === stageGroup.id) {              const subStages = [];              for (const subStg of stageGroup.stages) {                if (!subStg.is_condition && subStg.is_active === '1') {                  const currentUser = this.$store.getters.user.id;                  const stgDict = {                    start_date: sData.start,                    end_date: sData.end,                    planned_start_date: sData.start,                    planned_end_date: sData.end,                    created_user: currentUser,                    updated_user: currentUser,                    employee: sData.employee,                    sequence: subStg.sequence,                    stage: subStg.id,                    planned_work_hour: null,                    work_hour: null,                  };                  subStages.push(stgDict);                }              }              const fullStageDict = {                start_date: sData.start,                end_date: sData.end,                planned_start_date: sData.start,                planned_end_date: sData.end,                is_last: stageGroup.is_last,                sequence: stageGroup.sequence,                stage_group: sData.id,                employee: sData.employee,                planned_work_hour: null,                work_hour: null,                task_stages: subStages,              };              fullStage.push(fullStageDict);            }          }        }      }      return fullStage;    },    // -------------------------------------------------------------------------    // weekly-------------------------------------------------------------------    GenerateWeekly() {      const repeat = this.taskFrequency.repeat;      const result = [];      for (const task of this.taskStageGroup) {        if (task.is_repeated) {          const duration = task.end - task.start;          let dayName;          if (task.start === 1) {            dayName = 'mon';          } else if (task.start === 2) {            dayName = 'tue';          } else if (task.start === 3) {            dayName = 'wed';          } else if (task.start === 4) {            dayName = 'thu';          } else if (task.start === 5) {            dayName = 'fri';          } else if (task.start === 6) {            dayName = 'sat';          } else if (task.start === 7) {            dayName = 'sun';          }          const nextDay = this.getNextDayOfTheWeek(dayName, false);          const epochDay = duration * 1000 * 60 * 60 * 24;          const epochDate = nextDay.getTime() + epochDay;          const endDay = new Date(epochDate);          const total = { start: nextDay, end: endDay };          let i;          for (i = 0; i < repeat; i++) {            const repeated = this.repeaterWeekly(total, i, task.id);            result.push(repeated[0]);          }        } else {          const total = { start: task.start, end: task.end };          const repeated = this.repeaterWeekly(total, 0, task.id, false);          result.push(repeated[0]);        }      }      result[result.length - 1].is_last = true;      return result;    },    getNextDayOfTheWeek(      dayName,      excludeToday = true,      refDate = new Date(this.taskFrequency.startDate)    ) {      const dayOfWeek = [        'sun',        'mon',        'tue',        'wed',        'thu',        'fri',        'sat',      ].indexOf(dayName.slice(0, 3).toLowerCase());      if (dayOfWeek < 0) return;      refDate.setHours(0, 0, 0, 0);      refDate.setDate(        refDate.getDate() +          +!!excludeToday +          ((dayOfWeek + 7 - refDate.getDay() - +!!excludeToday) % 7)      );      return refDate;    },    repeaterWeekly(context, repeat, task_stage_group_id, can_repeat = true) {      let startDate = '';      let endDate = '';      if (can_repeat) {        const start = context.start;        const end = context.end;        const epochDay = repeat * 7 * 1000 * 60 * 60 * 24;        const epochStart = start.getTime() + epochDay;        const epochEnd = end.getTime() + epochDay;        // startDate = new Date(epochStart).toISOString().slice(0, 10);        // endDate = new Date(epochEnd).toISOString().slice(0, 10);        startDate = this.dateToString(new Date(epochStart));        endDate = this.dateToString(new Date(epochEnd));      } else {        startDate = context.start;        endDate = context.end;      }      const fullStage = [];      let algorithm;      for (const storeAlgorithm of this.$store.getters.company.algorithm) {        if (this.selectedAlgorithm === storeAlgorithm.id) {          algorithm = storeAlgorithm;          break;        }      }      for (const stageGroup of algorithm.stage_groups) {        if (stageGroup.is_active === '1') {          for (const sData of this.taskStageGroup) {            if (              sData.id === stageGroup.id &&              task_stage_group_id === sData.id            ) {              const subStages = [];              for (const subStg of stageGroup.stages) {                if (!subStg.is_condition && subStg.is_active === '1') {                  const currentUser = this.$store.getters.user.id;                  subStages.push({                    start_date: startDate,                    end_date: endDate,                    planned_start_date: startDate,                    planned_end_date: endDate,                    created_user: currentUser,                    updated_user: currentUser,                    employee: sData.employee,                    sequence: subStg.sequence,                    stage: subStg.id,                    planned_work_hour: null,                    work_hour: null,                  });                }              }              fullStage.push({                start_date: startDate,                end_date: endDate,                planned_start_date: startDate,                planned_end_date: endDate,                is_last: false,                sequence: stageGroup.sequence,                stage_group: sData.id,                employee: sData.employee,                planned_work_hour: null,                work_hour: null,                task_stages: subStages,              });            }          }        }      }      return fullStage;    },    // -------------------------------------------------------------------------    // monthly------------------------------------------------------------------    GenerateMonthly() {      const repeat = this.taskFrequency.repeat;      const result = [];      for (const task of this.taskStageGroup) {        if (task.is_repeated) {          let i;          for (i = 0; i < repeat; i++) {            const today = new Date(this.taskFrequency.startDate);            let start;            let end;            const checkDate = new Date(this.taskFrequency.startDate);            checkDate.setDate(task.start);            if (today <= checkDate) {              start = new Date(today.setDate(task.start));              end = new Date(today.setDate(task.end));            } else {              start = new Date(today.setMonth(today.getMonth() + 1));              start = new Date(start.setDate(task.start));              end = new Date(today.setDate(task.end));            }            const newStart = new Date(start.setMonth(start.getMonth() + i))              .toISOString()              .slice(0, 10);            const newEnd = new Date(end.setMonth(end.getMonth() + i))              .toISOString()              .slice(0, 10);            const repeated = this.repeater(newStart, newEnd, task.id);            for (const single of repeated) {              result.push(single);            }          }        } else {          const repeated = this.repeater(task.start, task.end, task.id);          for (const single of repeated) {            result.push(single);          }        }      }      result[result.length - 1].is_last = true;      return result;    },    // -------------------------------------------------------------------------    // quarterly----------------------------------------------------------------    GenerateQuarterly() {      const repeat = this.taskFrequency.repeat;      const result = [];      for (const task of this.taskStageGroup) {        if (task.is_repeated) {          let i;          for (i = 0; i < repeat; i++) {            const today = new Date(this.taskFrequency.startDate);            let start;            let end;            const checkDate = new Date(this.taskFrequency.startDate);            checkDate.setDate(task.start);            if (today <= checkDate) {              start = new Date(today.setDate(task.start));              end = new Date(today.setDate(task.end));            } else {              start = new Date(today.setMonth(today.getMonth() + 1));              start = new Date(start.setDate(task.start));              end = new Date(today.setDate(task.end));            }            const newStart = new Date(start.setMonth(start.getMonth() + i * 3))              .toISOString()              .slice(0, 10);            const newEnd = new Date(end.setMonth(end.getMonth() + i * 3))              .toISOString()              .slice(0, 10);            const repeated = this.repeater(newStart, newEnd, task.id);            for (const single of repeated) {              result.push(single);            }          }        } else {          const repeated = this.repeater(task.start, task.end, task.id);          for (const single of repeated) {            result.push(single);          }        }      }      result[result.length - 1].is_last = true;      return result;    },    // -------------------------------------------------------------------------    // b-annual-----------------------------------------------------------------    GenerateBiAnnual() {      const repeat = this.taskFrequency.repeat;      const result = [];      for (const task of this.taskStageGroup) {        if (task.is_repeated) {          let i;          for (i = 0; i < repeat; i++) {            const today = new Date(this.taskFrequency.startDate);            let start;            let end;            const checkDate = new Date(this.taskFrequency.startDate);            checkDate.setDate(task.start);            if (today <= checkDate) {              start = new Date(today.setDate(task.start));              end = new Date(today.setDate(task.end));            } else {              start = new Date(today.setMonth(today.getMonth() + 1));              start = new Date(start.setDate(task.start));              end = new Date(today.setDate(task.end));            }            const newStart = new Date(start.setMonth(start.getMonth() + i * 6))              .toISOString()              .slice(0, 10);            const newEnd = new Date(end.setMonth(end.getMonth() + i * 6))              .toISOString()              .slice(0, 10);            const repeated = this.repeater(newStart, newEnd, task.id);            for (const single of repeated) {              result.push(single);            }          }        } else {          const repeated = this.repeater(task.start, task.end, task.id);          for (const single of repeated) {            result.push(single);          }        }      }      result[result.length - 1].is_last = true;      return result;    },    // -------------------------------------------------------------------------    // annual-------------------------------------------------------------------    GenerateAnnually() {      const repeat = this.taskFrequency.repeat;      const result = [];      for (const task of this.taskStageGroup) {        if (task.is_repeated) {          let i;          for (i = 0; i < repeat; i++) {            const today = new Date(this.taskFrequency.startDate);            let start;            let end;            const checkDate = new Date(this.taskFrequency.startDate);            checkDate.setDate(task.start);            if (today <= checkDate) {              start = new Date(today.setDate(task.start));              end = new Date(today.setDate(task.end));            } else {              start = new Date(today.setMonth(today.getMonth() + 1));              start = new Date(start.setDate(task.start));              end = new Date(today.setDate(task.end));            }            const newStart = new Date(              start.setFullYear(start.getFullYear() + i)            )              .toISOString()              .slice(0, 10);            const newEnd = new Date(end.setFullYear(end.getFullYear() + i))              .toISOString()              .slice(0, 10);            const repeated = this.repeater(newStart, newEnd, task.id);            for (const single of repeated) {              result.push(single);            }          }        } else {          const repeated = this.repeater(task.start, task.end, task.id);          for (const single of repeated) {            result.push(single);          }        }      }      result[result.length - 1].is_last = true;      return result;    },    // -------------------------------------------------------------------------    repeater(startDate, endDate, task_stage_group_id) {      const fullStage = [];      let algorithm;      for (const storeAlgorithm of this.$store.getters.company.algorithm) {        if (this.selectedAlgorithm === storeAlgorithm.id) {          algorithm = storeAlgorithm;          break;        }      }      for (const stageGroup of algorithm.stage_groups) {        if (stageGroup.is_active === '1') {          for (const sData of this.taskStageGroup) {            if (              sData.id === stageGroup.id &&              task_stage_group_id === sData.id            ) {              const subStages = [];              for (const subStg of stageGroup.stages) {                if (!subStg.is_condition && subStg.is_active === '1') {                  const currentUser = this.$store.getters.user.id;                  subStages.push({                    start_date: startDate,                    end_date: endDate,                    planned_start_date: startDate,                    planned_end_date: endDate,                    created_user: currentUser,                    updated_user: currentUser,                    employee: sData.employee,                    sequence: subStg.sequence,                    stage: subStg.id,                    planned_work_hour: null,                    work_hour: null,                  });                }              }              fullStage.push({                start_date: startDate,                end_date: endDate,                planned_start_date: startDate,                planned_end_date: endDate,                is_last: false,                sequence: stageGroup.sequence,                stage_group: sData.id,                employee: sData.employee,                planned_work_hour: null,                work_hour: null,                task_stages: subStages,              });            }          }        }      }      return fullStage;    },    //converting date object to string /yyyy-mm-dd/    dateToString(dateObj) {      const year = dateObj.getFullYear();      const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');      const day = dateObj.getDate().toString().padStart(2, '0');      return `${year}-${month}-${day}`;    },    clearSidebar() {      this.taskName = null;      this.departmentSelected = null;      this.departmentManager = null;      this.taskTypesSelected = null;      this.functionsSelected = null;      this.selectedAlgorithm = null;      this.taskExecutor = null;      this.taskStageGroup = null;      this.taskTeam = null;      this.formSubmit = false;      this.newTaskId = 0;      this.taskStatusMessage = null;    },  },};</script>